---
file: map_rdf_properties.html
short: "How to: Map RDF properties"
title: How to map RDF properties using SPARQL Update
---

<p class="flow-text">You want to map RDF properties to properties from chosen RDF vocabularies. An inline table is a flexible way to specify mappings in SPARQL Update operations.</p>

<h3 class="header center orange-text">Problem</h3>

<p class="flow-text">For example, consider you have the following table about Bulgarian local administrative units that you want to convert to RDF:</p>

<table class="responsive-table">
  <thead>
    <tr>
      <th>LAU2_NAT_CODE</th>
      <th>NAME_1</th>
      <th>NAME_2_LAT</th>
      <th>CHANGE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>00045</td>
      <td>Мокрен</td>
      <td>Mokren</td>
      <td>2015-01-01</td>
    </tr>
    <tr>
      <td>00062</td>
      <td>Аврамово</td>
      <td>Avramovo</td>
      <td>2016-01-01</td>
    </tr>
    <tr>
      <td>62617</td>
      <td>Рибино</td>
      <td>Ribino</td>
      <td>2015-01-01</td>
    </tr>
  </tbody>
</table>

<p class="flow-text">You can automatically map this table to RDF using the <a href="{% link _components/t-tabular.html %}">Tabular</a> component, which derives properties from column names in a given namespace, such as <code>http://example.com/</code>:</p>

{% highlight turtle %}
@prefix : <http://example.com/> .

[ :CHANGE "2015-01-01" ;
  :LAU2_NAT_CODE "00045" ;
  :NAME_1 "Мокрен" ;
  :NAME_2_LAT "Mokren" ] .

[ :CHANGE "2016-01-01" ;
  :LAU2_NAT_CODE "00062" ;
  :NAME_1 "Аврамово" ;
  :NAME_2_LAT "Avramovo" ] .

[ :CHANGE "2015-01-01" ;
  :LAU2_NAT_CODE "62617" ;
  :NAME_1 "Рибино" ;
  :NAME_2_LAT "Ribino" ] .
{% endhighlight %}

<p class="flow-text">The initial mapping to RDF can be done via <a href="{% link /assets/tutorials/how-to/pipelines/how_to_map_rdf_properties_source.jsonld %}">this pipeline</a>:</p>

<div class="row">
  <div class="col s12 m8 offset-m2">
    <img alt="Source pipeline"
         class="responsive-img"
         data-caption="Source pipeline"
         src="{% link /assets/tutorials/how-to/img/map_rdf_properties_source_pipeline.png %}"/>
  </div>
</div>

<p class="flow-text">Consequently, you want to map the generated properties to properties from RDF vocabularies.</p>

<h3 class="header center orange-text">Solution</h3>

<p class="flow-text">Use a <a href="https://www.w3.org/TR/sparql11-update">SPARQL Update</a> operation that defines the mapping via the <a href="https://www.w3.org/TR/sparql11-query/#inline-data"><code>VALUES</code></a> clause. <code>VALUES</code> allows you to provide inline tabular data. In this case, you need two columns: one for the property in the source data and one for the property in the target RDF vocabulary:</p>

<pre><code>PREFIX :        &lt;http://example.com/&gt;
PREFIX dcterms: &lt;http://purl.org/dc/terms/&gt;
PREFIX skos:    &lt;http://www.w3.org/2004/02/skos/core#&gt;

DELETE {
  ?s ?source ?o .
}
INSERT {
  ?s ?target ?o .
}
WHERE {
  VALUES (?source         ?target) {
         (:LAU2_NAT_CODE  skos:notation)
         (:NAME_1         skos:prefLabel)
         (:NAME_2_LAT     skos:altLabel)
         (:CHANGE         dcterms:modified)
  }
  ?s ?source ?o .
}
</code></pre>

<p class="flow-text">Each row of the <code>VALUES</code> clause provides one mapping from a source property to a target property. In the example above, we map to properties from the <a href="https://www.w3.org/TR/skos-reference">Simple Knowledge Organization System</a>, such as <code>skos:prefLabel</code>, and <a href="http://dublincore.org/documents/dcmi-terms">Dublin Core Terms</a>, such as <code>dcterms:modified</code>. Using the SPARQL Update operation we delete the triples with the source property and insert the triples with the target property. If applied on the input data above, it produces the following result:</p>

{% highlight turtle %}
@prefix :        <http://example.com/> .
@prefix skos:    <http://www.w3.org/2004/02/skos/core#> .
@prefix dcterms: <http://purl.org/dc/terms/> .

[ dcterms:modified  "2015-01-01" ;
  skos:altLabel     "Ribino" ;
  skos:notation     "62617" ;
  skos:prefLabel    "Рибино" ] .

[ dcterms:modified  "2015-01-01" ;
  skos:altLabel     "Mokren" ;
  skos:notation     "00045" ;
  skos:prefLabel    "Мокрен" ] .

[ dcterms:modified  "2016-01-01" ;
  skos:altLabel     "Avramovo" ;
  skos:notation     "00062" ;
  skos:prefLabel    "Аврамово" ] .
{% endhighlight %}

<p class="flow-text">This mapping to properties can be executed via <a href="{% link /assets/tutorials/how-to/pipelines/how_to_map_rdf_properties_target.jsonld %}">this pipeline</a>:</p>

<div class="row">
  <div class="col s12 m8 offset-m2">
    <img alt="Target pipeline"
         class="responsive-img"
         data-caption="Target pipeline"
         src="{% link /assets/tutorials/how-to/img/map_rdf_properties_target_pipeline.png %}"/>
  </div>
</div>

<h3 class="header center orange-text">Discussion</h3>

<p class="flow-text">The declarative specification of the mappings allows you to extend the columns in the <code>VALUES</code> clause to provide additional instructions on how to map the data. For example, we can add a column <code>?typeOrLang</code> that indicates what datatype or language tag should be applied to the objects of the target properties. If we do not want any processing to be applied to the objects, we can use the keyword <code>UNDEF</code> instead of an RDF term. Literals with data types may be created via <a href="https://www.w3.org/TR/sparql11-query/#func-strdt"><code>strdt()</code></a> function. Likewise, you can make literals with language tags via the <a href="https://www.w3.org/TR/sparql11-query/#func-strlang"><code>strlang()</code></a> function.</p>

<pre><code>PREFIX :        &lt;http://example.com/&gt;
PREFIX dcterms: &lt;http://purl.org/dc/terms/&gt;
PREFIX skos:    &lt;http://www.w3.org/2004/02/skos/core#&gt;
PREFIX xsd:      &lt;http://www.w3.org/2001/XMLSchema#&gt;

DELETE {
  ?s ?source ?_o .
}
INSERT {
  ?s ?target ?o .
}
WHERE {
  VALUES (?source         ?target          ?typeOrLang) {
         (:LAU2_NAT_CODE  skos:notation    UNDEF)
         (:NAME_1         skos:prefLabel   "bg")
         (:NAME_2_LAT     skos:altLabel    UNDEF)
         (:CHANGE         dcterms:modified xsd:date)
  }
  ?s ?source ?_o .
  BIND (if(bound(?typeOrLang),
           if(isLiteral(?typeOrLang),
              strlang(?_o, ?typeOrLang),
              strdt(?_o, ?typeOrLang)),
           ?_o) AS ?o)
}
</code></pre>

<p class="flow-text">This update operation produces data in the following shape:</p>

{% highlight turtle %}
@prefix :        <http://example.com/> .
@prefix xsd:     <http://www.w3.org/2001/XMLSchema#> .
@prefix skos:    <http://www.w3.org/2004/02/skos/core#> .
@prefix dcterms: <http://purl.org/dc/terms/> .

[ dcterms:modified  "2015-01-01"^^xsd:date ;
  skos:altLabel     "Ribino" ;
  skos:notation     "62617" ;
  skos:prefLabel    "Рибино"@bg ] .

[ dcterms:modified  "2015-01-01"^^xsd:date ;
  skos:altLabel     "Mokren" ;
  skos:notation     "00045" ;
  skos:prefLabel    "Мокрен"@bg ] .

[ dcterms:modified  "2016-01-01"^^xsd:date ;
  skos:altLabel     "Avramovo" ;
  skos:notation     "00062" ;
  skos:prefLabel    "Аврамово"@bg ] .
{% endhighlight %}

<p class="flow-text">You may also use the <a href="{% link _components/t-sparqlconstruct.html %}">SPARQL CONSTRUCT component</a> to map RDF properties. The <code>CONSTRUCT</code> query form is handy when you want to ignore the data unaffected by the mapping, since <code>CONSTRUCT</code> queries return only the data that is explicitly created via the <code>CONSTRUCT</code> clause. In such case, you would remove the <code>DELETE</code> clause and change the <code>INSERT</code> to <code>CONSTRUCT</code> in the update operation above to obtain a mapping <code>CONSTRUCT</code> query.</p>

<h3 class="header center orange-text">See also</h3>

<p class="flow-text">Mapping RDF properties via <code>VALUES</code> is used in the <a href="{% link _tutorials/csv-to-rdf/describe_semantics.html %}">tutorial on converting tabular data to RDF</a>, where you can find more fleshed out examples of using this approach.</p>
