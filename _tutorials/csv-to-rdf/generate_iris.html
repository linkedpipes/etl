---
file: generate_iris.html
short: "CSV to RDF: generate IRIs"
subtitle: Generate IRIs
title: Converting tabular data to RDF
---

<p class="flow-text"><a href="{% link _tutorials/csv-to-rdf/describe_semantics.html %}" rel="prev">&larr; Previous step</a></p>

<p class="flow-text">Tabular outputs <a href="https://www.w3.org/TR/rdf11-concepts/#section-blank-nodes">blank nodes</a> by default.
Blank nodes are not stable identifiers, so they do not persist across queries or updates, which makes them difficult to manipulate in data transformations.
Since blank nodes are usually <em>“a convenience for the content provider and a burden on the content consumer”</em> (<a href="https://lists.w3.org/Archives/Public/semantic-web/2011Mar/0068.html">source</a>), we convert them to IRIs to make it easier to consume the data.
We mint IRIs within a domain under our control; in this case <a href="https://linked.opendata.cz">https://linked.opendata.cz</a>.
This avoids clashes with others creating IRIs in their namespaces and allows us to make the IRIs dereferenceable.</p>

<p class="flow-text">Since we want to avoid using the same IRI for multiple resources, we need to ensure that we base it on a unique key.
A safe choice of a unique identifier is UUID, which can be conveniently generated by the <a href="https://www.w3.org/TR/sparql11-query/#func-struuid"><code>struuid()</code></a> function in SPARQL, but UUID-based IRIs are less readable and prevent linking data by conveniently generating IRIs based on shared keys.
Instead, whenever possible we generate IRIs using simple or compound shared keys, such as the codes of local administrative units.</p>

<p class="flow-text">When you choose a key to use in IRIs, you should verify that it is available for all the resources that you want to create IRIs for and that the keys are unique.
To check if these requirements are violated, you can run a query with an <code>OPTIONAL</code> graph pattern matching the keys that groups by the key values and checks that each group contains exactly one solution. </p>

<pre><code>GROUP BY ?key1 ?key2 # more keys...
HAVING (COUNT(*) != 1)</code></pre>

<p class="flow-text">If such query returns non-empty results, then your key is non-unique and you need to change it.
For example, we can check whether LAU level 1 codes overlap between countries by using a similar query.</p>

<pre><code>PREFIX : &lt;http://example.com/&gt;

SELECT ?lau1Notation
WHERE {
  [] :LAU1_NAT_CODE ?lau1Notation ;
    :sheet_name ?country .
}
GROUP BY ?lau1Notation
HAVING (COUNT(DISTINCT ?country) &gt; 1)</code></pre>

<p class="flow-text">This query returns non-empty results indicating that some countries share the same LAU1 codes.
Therefore, we need to include country codes in IRIs of LAU1.
In this step we also map LAU1 labels, provided by the <code>:LAU1_NAME</code> property, and link to the concept scheme in which LAU1 codes belong.</p>

<pre><code>PREFIX :     &lt;http://example.com/&gt;
PREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;

DELETE {
  ?lau2 :LAU1_NAT_CODE ?lau1Notation ;
    :LAU1_NAME ?lau1PrefLabel .
}
INSERT {
  ?lau2 skos:broaderTransitive ?lau1 .
  ?lau1 a skos:Concept ;
    skos:prefLabel ?lau1PrefLabel ;
    skos:inScheme &lt;https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016&gt; .
}
WHERE {
  ?lau2 :LAU1_NAT_CODE ?lau1Notation ;
    :sheet_name ?country .
  BIND (iri(concat("https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016/",
                   lcase(?country),
                   "/",
                   ?lau1Notation)) AS ?lau1)
  OPTIONAL {
    ?lau2 :LAU1_NAME ?lau1PrefLabel .
  }
}</code></pre>

<p class="flow-text">Next, we generate IRIs for local administrative units on the level 2.
This step is more convoluted because not all LAU2 have codes and when their codes are available they may not be unique per country. For example, the LAU2 code <code>32010</code> in the column <code>LAU2_NAT_CODE</code> is shared among several countries, such as Belgium, Bulgaria, and Ireland:</p>

<table class="responsive-table">
  <thead>
    <tr>
      <th>NUTS_3</th>
      <th>LAU1_NAT_CODE</th>
      <th>LAU2_NAT_CODE</th>
      <th>CHANGE</th>
      <th>NAME_1</th>
      <th>NAME_2_LAT</th>
      <th>POP</th>
      <th>AREA</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>BE252</td>
      <td>n.a.</td>
      <td>32010</td>
      <td>no</td>
      <td>Koekelare</td>
      <td>Koekelare</td>
      <td>8761</td>
      <td>39185258</td>
    </tr>
    <tr>
      <td>BG423</td>
      <td>PAZ19</td>
      <td>32010</td>
      <td>no</td>
      <td>Ивайло</td>
      <td>Ivaylo</td>
      <td>2750</td>
      <td>14078000</td>
    </tr>
    <tr>
      <td>IE011</td>
      <td>01</td>
      <td>32010</td>
      <td>no</td>
      <td>Mullagh</td>
      <td>Mullagh</td>
      <td>n.a</td>
      <td>2440000</td>
    </tr>
  </tbody>
</table>

<p class="flow-text">In order to address these limitations, we generate UUID-based IRIs for LAU2 without codes and include LAU1 codes in LAU2 IRIs to disambiguate the administrative units within countries.
However, not all LAU2 codes link a LAU1 code, so its inclusion is optional.</p>

<pre><code>PREFIX :     &lt;http://example.com/&gt;
PREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;

DELETE {
  ?_lau2 ?p ?o .
}
INSERT {
  ?lau2 ?p ?o .
}
WHERE {
  {
    SELECT ?_lau2 ?lau2
    WHERE {
      ?_lau2 :sheet_name ?country .
      OPTIONAL {
        # There are some LAU2 without a code.
        ?_lau2 skos:notation ?code .
      }
      OPTIONAL {
        ?_lau2 skos:broaderTransitive/skos:notation ?lau1 .
      }
      BIND (if(bound(?code),
               concat(lcase(?country),
                      "/",
                      if(bound(?lau1), concat(encode_for_uri(lcase(?lau1)), "/"), ""),
                      encode_for_uri(lcase(?code))),
               struuid()) AS ?key)
      BIND (iri(concat("https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016/", ?key))
            AS ?lau2)
    }
  }
  ?_lau2 ?p ?o .
}</code></pre>

<p class="flow-text">Some local administrative units refer to codes of their parent NUTS regions via the <code>:NUTS_3</code> or <code>:NUTS3_13</code> properties.
<a href="http://ec.europa.eu/eurostat/web/nuts/overview">NUTS</a> (Nomenclature of territorial units for statistics) divides the EU into hierarchically organized regions that serve the purpose of aggregating statistics.
There are unofficial versions of NUTS in RDF that correspond to older versions of NUTS.
However, our dataset links the current version of NUTS from 2013.
Hence, we cannot reuse the existing RDF versions.
Instead, we mint our own IRIs for NUTS regions on the level 3.
Besides providing NUTS regions with IRIs we link them as parents to LAU2 via <code>skos:broaderTransitive</code>; either directly or indirectly through their parent LAU1, if present.</p>

<pre><code>PREFIX :     &lt;http://example.com/&gt;
PREFIX skos: &lt;http://www.w3.org/2004/02/skos/core#&gt;

DELETE {
  ?lau2 ?nutsProperty ?notation .
}
INSERT {
  ?narrower skos:broaderTransitive ?nuts3 .
  ?nuts3 a skos:Concept ;
    skos:notation ?notation ;
    skos:inScheme &lt;https://linked.opendata.cz/resource/ec.europa.eu/eurostat/nuts/2013&gt; .
}
WHERE {
  VALUES ?nutsProperty {
    :NUTS_3
    :NUTS3_13
  }
  ?lau2 ?nutsProperty ?notation ;
    :sheet_name ?country .
  BIND (if(strstarts(?notation, ucase(?country)), ?notation, concat(ucase(?country), ?notation))
        AS ?key)
  BIND (iri(concat("https://linked.opendata.cz/resource/ec.europa.eu/eurostat/nuts/2013/", ?key))
        AS ?nuts3)
  OPTIONAL {
    ?lau2 skos:broaderTransitive ?lau1 .
  }
  BIND (coalesce(?lau1, ?lau2) AS ?narrower)
}</code></pre>

<p class="flow-text">The remaining blank nodes in the data after these steps identify the deprecated LAU from 2015.
These LAU are explicitly linked via the <code>dcterms:replaces</code> property, which we added in one of the previous steps.
We generate code-based IRIs for the deprecated LAU, both on the level 1 and 2.</p>

<pre><code>PREFIX :        &lt;http://example.com/&gt;
PREFIX dcterms: &lt;http://purl.org/dc/terms/&gt;
PREFIX skos:    &lt;http://www.w3.org/2004/02/skos/core#&gt;

DELETE {
  ?newLau2 dcterms:replaces ?_oldLau2 .
  ?_oldLau2 ?p ?o .
}
INSERT {
  ?newLau2 dcterms:replaces ?oldLau2 .
  ?oldLau2 a skos:Concept ;
    skos:inScheme &lt;https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2015&gt; ;
    skos:notation ?oldLau2Notation ;
    skos:broaderTransitive ?oldLau1 .
  ?oldLau1 a skos:Concept ;
    skos:inScheme &lt;https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2015&gt; ;
    skos:notation ?oldLau1Notation .
}
WHERE {
  ?newLau2 dcterms:replaces ?_oldLau2 ;
    :sheet_name ?country .
  OPTIONAL {
    ?_oldLau2 skos:notation ?oldLau2Notation .
  }
  BIND ("https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2015/" AS ?ns)
  OPTIONAL {
    ?_oldLau2 skos:broaderTransitive/skos:notation ?oldLau1Notation .
    BIND (iri(concat(?ns,
                     lcase(?country),
                     "/",
                     ?oldLau1Notation)) AS ?oldLau1)
  }
  BIND (if(bound(?oldLau2Notation),
           concat(lcase(?country),
                  "/",
                  if(bound(?oldLau1Notation), concat(encode_for_uri(lcase(?oldLau1Notation)), "/"), ""),
                  encode_for_uri(lcase(?oldLau2Notation))),
           struuid()) AS ?key)
  BIND (iri(concat(?ns, ?key)) AS ?oldLau2)
  ?_oldLau2 ?p ?o .
}</code></pre>

<ul class="collapsible popout" data-collapsible="accordion">
  <li>
    <div class="collapsible-header"><i class="material-icons">open_with</i>Sample RDF output</div>
    <div class="collapsible-body">
{% highlight turtle %}
@prefix :     <http://example.com/> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix xsd:  <http://www.w3.org/2001/XMLSchema#> .

<https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016/fi/005> a skos:Concept ;
  skos:prefLabel "Alajärvi"@fi ;
  skos:notation "005" ;
  skos:broaderTransitive <https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016/fi/146> ;
  skos:inScheme <https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016> ;
  :AREA "1056740000"^^xsd:decimal ;
  :CHANGE false ;
  :POP 10006 ;
  :sheet_name "FI" .

<https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016/fi/050> a skos:Concept ;
  skos:prefLabel "Eura"@fi ;
  skos:notation "050" ;
  skos:broaderTransitive <https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016/fi/041> ;
  skos:inScheme <https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016> ;
  :AREA "630200000"^^xsd:decimal ;
  :CHANGE false ;
  :POP 12128 ;
  :sheet_name "FI" .

<https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016/fi/592> a skos:Concept ;
  skos:prefLabel "Petäjävesi"@fi ;
  skos:notation "592" ;
  skos:broaderTransitive <https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016/fi/131> ;
  skos:inScheme <https://linked.opendata.cz/resource/ec.europa.eu/eurostat/lau/2016> ;
  :AREA "495420000"^^xsd:decimal ;
  :CHANGE false ;
  :POP 4008 ;
  :sheet_name "FI" .
{% endhighlight %}
    </div>
  </li>
</ul>

<p class="flow-text">
  <a href="{% link _tutorials/csv-to-rdf/split_statistics_and_the_lau_code_list.html %}"
     rel="next">&rarr; Next step</a>
</p>
